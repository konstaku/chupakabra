import {
  require_Context,
  require_interopRequireDefault,
  require_utils
} from "./chunk-C6K6GWMW.js";
import {
  require_react_is
} from "./chunk-EAA7X2X6.js";
import {
  require_classnames
} from "./chunk-CZMLBV2H.js";
import {
  __commonJS,
  require_react
} from "./chunk-5VZC3UST.js";

// node_modules/@babel/runtime/helpers/typeof.js
var require_typeof = __commonJS({
  "node_modules/@babel/runtime/helpers/typeof.js"(exports, module) {
    function _typeof(o) {
      "@babel/helpers - typeof";
      return module.exports = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, module.exports.__esModule = true, module.exports["default"] = module.exports, _typeof(o);
    }
    module.exports = _typeof, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/interopRequireWildcard.js
var require_interopRequireWildcard = __commonJS({
  "node_modules/@babel/runtime/helpers/interopRequireWildcard.js"(exports, module) {
    var _typeof = require_typeof()["default"];
    function _getRequireWildcardCache(e) {
      if ("function" != typeof WeakMap)
        return null;
      var r = /* @__PURE__ */ new WeakMap(), t = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function _getRequireWildcardCache2(e2) {
        return e2 ? t : r;
      })(e);
    }
    function _interopRequireWildcard(e, r) {
      if (!r && e && e.__esModule)
        return e;
      if (null === e || "object" != _typeof(e) && "function" != typeof e)
        return {
          "default": e
        };
      var t = _getRequireWildcardCache(r);
      if (t && t.has(e))
        return t.get(e);
      var n = {
        __proto__: null
      }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var u in e)
        if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) {
          var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
          i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
        }
      return n["default"] = e, t && t.set(e, n), n;
    }
    module.exports = _interopRequireWildcard, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/rc-util/lib/hooks/useMemo.js
var require_useMemo = __commonJS({
  "node_modules/rc-util/lib/hooks/useMemo.js"(exports) {
    "use strict";
    var _interopRequireWildcard = require_interopRequireWildcard().default;
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = useMemo;
    var React = _interopRequireWildcard(require_react());
    function useMemo(getValue, condition, shouldUpdate) {
      var cacheRef = React.useRef({});
      if (!("value" in cacheRef.current) || shouldUpdate(cacheRef.current.condition, condition)) {
        cacheRef.current.value = getValue();
        cacheRef.current.condition = condition;
      }
      return cacheRef.current.value;
    }
  }
});

// node_modules/rc-util/lib/ref.js
var require_ref = __commonJS({
  "node_modules/rc-util/lib/ref.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault().default;
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.composeRef = composeRef;
    exports.fillRef = fillRef;
    exports.supportNodeRef = supportNodeRef;
    exports.supportRef = supportRef;
    exports.useComposeRef = useComposeRef;
    var _typeof2 = _interopRequireDefault(require_typeof());
    var _react = require_react();
    var _reactIs = require_react_is();
    var _useMemo = _interopRequireDefault(require_useMemo());
    function fillRef(ref, node) {
      if (typeof ref === "function") {
        ref(node);
      } else if ((0, _typeof2.default)(ref) === "object" && ref && "current" in ref) {
        ref.current = node;
      }
    }
    function composeRef() {
      for (var _len = arguments.length, refs = new Array(_len), _key = 0; _key < _len; _key++) {
        refs[_key] = arguments[_key];
      }
      var refList = refs.filter(function(ref) {
        return ref;
      });
      if (refList.length <= 1) {
        return refList[0];
      }
      return function(node) {
        refs.forEach(function(ref) {
          fillRef(ref, node);
        });
      };
    }
    function useComposeRef() {
      for (var _len2 = arguments.length, refs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        refs[_key2] = arguments[_key2];
      }
      return (0, _useMemo.default)(function() {
        return composeRef.apply(void 0, refs);
      }, refs, function(prev, next) {
        return prev.length !== next.length || prev.every(function(ref, i) {
          return ref !== next[i];
        });
      });
    }
    function supportRef(nodeOrComponent) {
      var _type$prototype, _nodeOrComponent$prot;
      var type = (0, _reactIs.isMemo)(nodeOrComponent) ? nodeOrComponent.type.type : nodeOrComponent.type;
      if (typeof type === "function" && !((_type$prototype = type.prototype) !== null && _type$prototype !== void 0 && _type$prototype.render)) {
        return false;
      }
      if (typeof nodeOrComponent === "function" && !((_nodeOrComponent$prot = nodeOrComponent.prototype) !== null && _nodeOrComponent$prot !== void 0 && _nodeOrComponent$prot.render)) {
        return false;
      }
      return true;
    }
    function supportNodeRef(node) {
      if (!(0, _react.isValidElement)(node)) {
        return false;
      }
      if ((0, _reactIs.isFragment)(node)) {
        return false;
      }
      return supportRef(node);
    }
  }
});

// node_modules/@ant-design/icons/lib/components/Icon.js
var require_Icon = __commonJS({
  "node_modules/@ant-design/icons/lib/components/Icon.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _default;
      }
    });
    var _react = _interop_require_wildcard(require_react());
    var _classnames = _interop_require_default(require_classnames());
    var _ref = require_ref();
    var _Context = _interop_require_default(require_Context());
    var _utils = require_utils();
    function _define_property(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interop_require_wildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
          default: obj
        };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _object_spread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys2 = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
          ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
            return Object.getOwnPropertyDescriptor(source, sym).enumerable;
          }));
        }
        ownKeys2.forEach(function(key) {
          _define_property(target, key, source[key]);
        });
      }
      return target;
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly) {
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
        }
        keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _object_spread_props(target, source) {
      source = source != null ? source : {};
      if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _object_without_properties(source, excluded) {
      if (source == null)
        return {};
      var target = _object_without_properties_loose(source, excluded);
      var key, i;
      if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for (i = 0; i < sourceSymbolKeys.length; i++) {
          key = sourceSymbolKeys[i];
          if (excluded.indexOf(key) >= 0)
            continue;
          if (!Object.prototype.propertyIsEnumerable.call(source, key))
            continue;
          target[key] = source[key];
        }
      }
      return target;
    }
    function _object_without_properties_loose(source, excluded) {
      if (source == null)
        return {};
      var target = {};
      var sourceKeys = Object.keys(source);
      var key, i;
      for (i = 0; i < sourceKeys.length; i++) {
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0)
          continue;
        target[key] = source[key];
      }
      return target;
    }
    var Icon = _react.forwardRef(function(props, ref) {
      var className = props.className, Component = props.component, viewBox = props.viewBox, spin = props.spin, rotate = props.rotate, tabIndex = props.tabIndex, onClick = props.onClick, children = props.children, restProps = _object_without_properties(props, [
        "className",
        "component",
        "viewBox",
        "spin",
        "rotate",
        "tabIndex",
        "onClick",
        "children"
      ]);
      var iconRef = _react.useRef();
      var mergedRef = (0, _ref.useComposeRef)(iconRef, ref);
      (0, _utils.warning)(Boolean(Component || children), "Should have `component` prop or `children`.");
      (0, _utils.useInsertStyles)(iconRef);
      var _React_useContext = _react.useContext(_Context.default), _React_useContext_prefixCls = _React_useContext.prefixCls, prefixCls = _React_useContext_prefixCls === void 0 ? "anticon" : _React_useContext_prefixCls, rootClassName = _React_useContext.rootClassName;
      var classString = (0, _classnames.default)(rootClassName, prefixCls, className);
      var svgClassString = (0, _classnames.default)(_define_property({}, "".concat(prefixCls, "-spin"), !!spin));
      var svgStyle = rotate ? {
        msTransform: "rotate(".concat(rotate, "deg)"),
        transform: "rotate(".concat(rotate, "deg)")
      } : void 0;
      var innerSvgProps = _object_spread_props(_object_spread({}, _utils.svgBaseProps), {
        className: svgClassString,
        style: svgStyle,
        viewBox
      });
      if (!viewBox) {
        delete innerSvgProps.viewBox;
      }
      var renderInnerNode = function() {
        if (Component) {
          return _react.createElement(Component, innerSvgProps, children);
        }
        if (children) {
          (0, _utils.warning)(Boolean(viewBox) || _react.Children.count(children) === 1 && _react.isValidElement(children) && _react.Children.only(children).type === "use", "Make sure that you provide correct `viewBox` prop (default `0 0 1024 1024`) to the icon.");
          return _react.createElement("svg", _object_spread_props(_object_spread({}, innerSvgProps), {
            viewBox
          }), children);
        }
        return null;
      };
      var iconTabIndex = tabIndex;
      if (iconTabIndex === void 0 && onClick) {
        iconTabIndex = -1;
      }
      return _react.createElement("span", _object_spread_props(_object_spread({
        role: "img"
      }, restProps), {
        ref: mergedRef,
        tabIndex: iconTabIndex,
        onClick,
        className: classString
      }), renderInnerNode());
    });
    Icon.displayName = "AntdIcon";
    var _default = Icon;
  }
});
export default require_Icon();
//# sourceMappingURL=@ant-design_icons_lib_components_Icon.js.map
